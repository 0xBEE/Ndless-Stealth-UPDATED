#!/bin/bash
# bash and not sh: we use bash arrays
# New ld which produces bFLT binaries.
#
# Available non-GCC options:
# --debug: show elf2flt verbose messages

UNAME=`uname -s | tr '[A-Z]' '[a-z]'`
DIRNAME=`dirname "$0"`

# DIRNAME may not be in the toolchain directory if this script was symlinked.
# try to find the symlink target	
which readlink >/dev/null 2>&1 && readlink "$0" >/dev/null 2>&1 && {
    SYMLINK=`readlink "$0"`
    
    # On MacOS X, the readlink command hasn't the same behavior than the others operating systems based on Unix.
    if [ "$UNAME" == "darwin" ]; then
    	DIRNAME=`dirname "$SYMLINK"`
    else
    	DIRNAME="$SYMLINK"/..
    fi
}

# Cygwin owns a dedicated command to find the symlink target
if [ "$UNAME" = "cygwin" ]; then
	DIRNAME=`cygpath --path --windows "$DIRNAME"`
fi

debug=false
stdlib="-lSDL_gfx -lSDL_image -lSDL -lnspireio -lstdc++ -lndls -Wl,--start-group -lsyscalls -lc -Wl,--end-group -lgcc"
# an array is used to change the arguments while supporting arguments with spaces
declare -a args
for arg in "$@"; do
	case $arg in
		--debug) debug=true;;
		-nostdlib) stdlib="";;
		*) args=("${args[@]}" $arg);;
	esac
done

# some newlib symbols are not found if ld is used...
GCC=`(which arm-elf-g++ arm-none-eabi-g++ arm-linux-gnueabi-g++ | head -1) 2>/dev/null`
# lazy system build: must be built with the same toolchain
(cd "$DIRNAME/../system" && make -s all)
ret=$?
if [ $ret -ne 0 ]; then
	exit $ret
fi

home="${USERPROFILE:-$HOME}"
mkdir -p "$home/.ndless/lib"

elf2flt_args=""
if $debug; then
	elf2flt_args="-v"
fi

"$GCC" -Wl,-elf2flt=$elf2flt_args -fPIC -nostdlib -nostartfiles -T "$DIRNAME/../system/ldscript" -L "$DIRNAME/../lib" -L "$home/.ndless/lib" -static "$DIRNAME/../system/crt0.o" "$DIRNAME/../system/crti.o" "${args[@]}" $stdlib "$DIRNAME/../system/crtn.o"
